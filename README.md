# Тестовое задание от MEDODS
## Часть сервиса аутентификации
### Общая информация
Сервис содержит 2 маршрута:
* Recieve
* Refresh

UID в обоих случаях передается через параметры:
* localhost:8080/recieve?userid=`uid пользователя`
* localhost:8080/refresh?userid=`uid пользователя`\
В случае пустого или неуказанного `userid` сервер отправляет `Status 400: Bad Request`

В обоих токенах в Claims указывается `Timestamp: time.Now().Unix()` для связи Access и Refresh токенов и проверки валидности пары при Refresh-операции

В процессе тестирования использовались:
* MondoDBCompass
* Postman

*Примечание: конфигурацию приложения и базы данных можно изменить в файлах config.go в соответствующих каталогах внутри `pkg`*

### Access-токен
Алгоритм подписи: SHA-512\
Время экспирации: 5 минут\
Формат передачи: base64\
Хранение: HttpOnly Cookies\
*Примечание: также следует менять значение флага `Secure: true`, чтобы Cookie-файлы передавались только через защищенный протокол HTTPS*

Содержимое payload:
* UserID
* Timestamp

### Refresh-токен
Алгоритм подписи: SHA-512\
Время экспирации: 24 часа\
Формат передачи: base64\
Хранение: MongoDB\
Формат хранения: bcrypt-хеш

Содержимое payload:
* UserID
* Timestamp

### Recieve-маршрут
При получении запроса по этому маршруту сервис создаёт новый документ в базе данных с `"_id" = uid` и привязывает к идентификатору пару токенов.\
Access-токен шифруется алгоритмом base64, упаковывается в Cookie и отправляется пользователю.\
Refresh-токен шифруется алгоритмом base64, упаковывается в Cookie, отправляется пользователю, а также хешируется и записывается в документ с `"_id" = uid`\
В случае, если данная запись уже существует, сервер отправляет пользователю сообщение `Status 400: Bad Request. User already exists`

### Refresh-маршрут
При получении запроса по этому маршруту сервис:
1. Извлекает пару токенов из Cookies в формате base64
2. Расшифровывает токены
3. Получает хеш Refresh-токена из базы данных и сопоставляет хеш с полученным токеном
4. Сопоставляет `UserID` и `Timestamp` Access и Refresh токенов, проверяя пару на валидность
5. Выдаёт пользователю новую пару токенов, зашифрованную алгоритмом base64 и упакованную в Cookies
6. Хеширует новый Refresh-токен и обновляет документ в базе данных
